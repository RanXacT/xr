// ######################################################################################### - FILE
/*!

\author Daniel Craig \par Copyright 2016, All Rights reserved.
*/
// ######################################################################################### - FILE

// ######################################################################################### - FILE
/* Includes */
// ######################################################################################### - FILE
#ifndef XR_DEFINES_H
#include "xr/defines.h"
#endif
#ifndef XR_CORE_HASH_SHA_H
#include "xr/core/hash/sha.h"
#endif
#ifndef XR_CORE_HASH_MD5_H
#include "xr/core/hash/md5.h"
#endif
#ifndef XR_CORE_HASH_CRC_H
#include "xr/core/hash/crc.h"
#endif
#ifndef XR_CORE_HASH_CRC32C_H
#include "xr/core/hash/crc32c.h"
#endif
#ifndef XR_CORE_ASSERT_H
#include "xr/core/assert.h"
#endif
#ifndef XR_CORE_TEST_H
#include "xr/core/test.h"
#endif
#ifndef XR_CORE_MEM_UTILS_H
#include "xr/core/mem_utils.h"
#endif
#include <intrin.h>
// ######################################################################################### - FILE
/* Unit Tests                                                                */
// ######################################################################################### - FILE
#if defined(XR_TEST_FEATURES_ENABLED)

// ######################################################################################### - FILE
// ######################################################################################### - FILE
XR_UNITTEST_GROUP_BEGIN( SHA )

xr::Core::CRC32::Digest sDigestNullStringCRC32 = {
    0
};

xr::Core::CRC32::Digest sDigestHelloCRC32 = {
    0xF7D18982
};

xr::Core::CRC32::Digest sDigestTestVectorCRC32 = {
    0x9D2407FA
};

xr::Core::CRC32::Digest sDigestNullStringCRC32C = {
    0
};

xr::Core::CRC32::Digest sDigestHelloCRC32C = {
    0XC4AB782E
};

xr::Core::CRC32::Digest sDigestTestVectorCRC32C = {
    0XD877C4C3
};

xr::Core::MD5::Digest sDigestNullStringMD5 = {
    { 0xd4,0x1d,0x8c,0xd9,0x8f,0x00,0xb2,0x04,0xe9,0x80,0x09,0x98,0xec,0xf8,0x42,0x7e }
};

xr::Core::MD5::Digest sDigestHelloMD5 = {
    { 0x8b,0x1a,0x99,0x53,0xc4,0x61,0x12,0x96,0xa8,0x27,0xab,0xf8,0xc4,0x78,0x04,0xd7 }
};

xr::Core::MD5::Digest sDigestTestVectorMD5 = {
    { 0x37,0xaa,0xe2,0x07,0xa5,0x4c,0x35,0xd0,0x09,0x8e,0xed,0xcc,0xf5,0xdf,0x95,0xcb }
};

xr::Core::SHA1_160::Digest sDigestNullStringSHA1 = {
    { 0xda,0x39,0xa3,0xee,0x5e,0x6b,0x4b,0x0d,0x32,0x55,0xbf,0xef,0x95,0x60,0x18,0x90,0xaf,0xd8,0x07,0x09}
};

xr::Core::SHA1_160::Digest sDigestHelloSHA1 = {
    { 0xf7,0xff,0x9e,0x8b,0x7b,0xb2,0xe0,0x9b,0x70,0x93,0x5a,0x5d,0x78,0x5e,0x0c,0xc5,0xd9,0xd0,0xab,0xf0}
};

xr::Core::SHA1_160::Digest sDigestTestVectorSHA1 = {
    { 0xa9,0xd5,0xb4,0xea,0x9c,0x86,0xf8,0x83,0x4e,0xb2,0x16,0x52,0x14,0xcf,0xd0,0x00,0x48,0xc3,0x2b,0x3e }
};


xr::Core::SHA1_224::Digest sDigestNullString224 = {
    { 0xd1,0x4a,0x02,0x8c,0x2a,0x3a,0x2b,0xc9,0x47,0x61,0x02,0xbb,0x28,0x82,0x34,0xc4,0x15,0xa2,0xb0,0x1f,0x82,0x8e,0xa6,0x2a,0xc5,0xb3,0xe4,0x2f }
};

xr::Core::SHA1_224::Digest sDigestHello224 = {
    { 0x41,0x49,0xda,0x18,0xaa,0x8b,0xfc,0x2b,0x1e,0x38,0x2c,0x6c,0x26,0x55,0x6d,0x01,0xa9,0x2c,0x26,0x1b,0x64,0x36,0xda,0xd5,0xe3,0xbe,0x3f,0xcc }
};

xr::Core::SHA1_224::Digest sDigestTestVector224 = {
    { 0x30,0x0e,0x94,0x50,0xfd,0x35,0x54,0x1a,0xd6,0x34,0x34,0xc0,0x9b,0x44,0xcb,0x7c,0xcf,0xc9,0xdc,0x61,0x9e,0xac,0x41,0x25,0x98,0x1a,0x74,0x5f }
};


xr::Core::SHA1_256::Digest sDigestNullString256 = {
    { 0xe3,0xb0,0xc4,0x42,0x98,0xfc,0x1c,0x14,0x9a,0xfb,0xf4,0xc8,0x99,0x6f,0xb9,0x24,0x27,0xae,0x41,0xe4,0x64,0x9b,0x93,0x4c,0xa4,0x95,0x99,0x1b,0x78,0x52,0xb8,0x55 }
};

xr::Core::SHA1_256::Digest sDigestHello256 = {
    { 0x18,0x5f,0x8d,0xb3,0x22,0x71,0xfe,0x25,0xf5,0x61,0xa6,0xfc,0x93,0x8b,0x2e,0x26,0x43,0x06,0xec,0x30,0x4e,0xda,0x51,0x80,0x07,0xd1,0x76,0x48,0x26,0x38,0x19,0x69}
};

xr::Core::SHA1_256::Digest sDigestTestVector256 = {
    {0x9a,0x85,0xc8,0x66,0x77,0x98,0x42,0x5f,0x82,0xe4,0x1d,0x72,0xa4,0xbf,0x3c,0x59,0x01,0xcc,0xfb,0x72,0x6f,0x62,0x86,0x80,0x48,0xdd,0xbc,0x19,0x34,0xab,0x18,0xad}
};

xr::Core::SHA1_512::Digest sDigestNullString512 = {
    {0xcf,0x83,0xe1,0x35,0x7e,0xef,0xb8,0xbd,0xf1,0x54,0x28,0x50,0xd6,0x6d,0x80,0x07,0xd6,0x20,0xe4,0x05,0x0b,0x57,0x15,0xdc,0x83,0xf4,0xa9,0x21,0xd3,0x6c,0xe9,0xce,0x47,0xd0,0xd1,0x3c,0x5d,0x85,0xf2,0xb0,0xff,0x83,0x18,0xd2,0x87,0x7e,0xec,0x2f,0x63,0xb9,0x31,0xbd,0x47,0x41,0x7a,0x81,0xa5,0x38,0x32,0x7a,0xf9,0x27,0xda,0x3e}
};

xr::Core::SHA1_512::Digest sDigestHello512 = {
    {0x36,0x15,0xf8,0x0c,0x9d,0x29,0x3e,0xd7,0x40,0x26,0x87,0xf9,0x4b,0x22,0xd5,0x8e,0x52,0x9b,0x8c,0xc7,0x91,0x6f,0x8f,0xac,0x7f,0xdd,0xf7,0xfb,0xd5,0xaf,0x4c,0xf7,0x77,0xd3,0xd7,0x95,0xa7,0xa0,0x0a,0x16,0xbf,0x7e,0x7f,0x3f,0xb9,0x56,0x1e,0xe9,0xba,0xae,0x48,0x0d,0xa9,0xfe,0x7a,0x18,0x76,0x9e,0x71,0x88,0x6b,0x03,0xf3,0x15}
};

xr::Core::SHA1_512::Digest sDigestTestVector512 = {
    {0xd3,0x2b,0x14,0xdd,0x7c,0xc9,0xbf,0x27,0xa1,0x80,0x37,0xc0,0x57,0xb2,0x7b,0xeb,0xe0,0x5e,0xb5,0x36,0xf9,0x03,0x53,0x24,0xa6,0x4d,0x59,0x8b,0xfd,0x64,0x2f,0x32,0xd7,0x73,0x2d,0x18,0x55,0xbe,0x0a,0x8e,0xc7,0xc4,0x64,0xcc,0x6b,0x9a,0x4c,0xc7,0x4a,0x69,0x88,0x3e,0x74,0x87,0x51,0x05,0xc7,0x20,0x3b,0x75,0x11,0x70,0x12,0x1e}
};

xr::Core::SHA1_384::Digest sDigestNullString384 = {
    {0x38,0xb0,0x60,0xa7,0x51,0xac,0x96,0x38,0x4c,0xd9,0x32,0x7e,0xb1,0xb1,0xe3,0x6a,0x21,0xfd,0xb7,0x11,0x14,0xbe,0x07,0x43,0x4c,0x0c,0xc7,0xbf,0x63,0xf6,0xe1,0xda,0x27,0x4e,0xde,0xbf,0xe7,0x6f,0x65,0xfb,0xd5,0x1a,0xd2,0xf1,0x48,0x98,0xb9,0x5b}
};

xr::Core::SHA1_384::Digest sDigestHello384 = {
    {0x35,0x19,0xfe,0x5a,0xd2,0xc5,0x96,0xef,0xe3,0xe2,0x76,0xa6,0xf3,0x51,0xb8,0xfc,0x0b,0x03,0xdb,0x86,0x17,0x82,0x49,0x0d,0x45,0xf7,0x59,0x8e,0xbd,0x0a,0xb5,0xfd,0x55,0x20,0xed,0x10,0x2f,0x38,0xc4,0xa5,0xec,0x83,0x4e,0x98,0x66,0x80,0x35,0xfc}
};

xr::Core::SHA1_384::Digest sDigestTestVector384 = {
    {0x7a,0x08,0x57,0x0b,0xa5,0xaa,0x38,0x85,0x8a,0xc0,0x14,0xcb,0x5f,0x1a,0x86,0xb0,0x5b,0x02,0xcf,0xe0,0x66,0x52,0x61,0x70,0xa2,0x7f,0xe3,0xab,0x05,0x48,0x90,0xa5,0xd2,0x9d,0x87,0xab,0x1d,0xd8,0x34,0xd8,0x61,0xfa,0xfa,0xf1,0x28,0x12,0x6c,0x70}
};

template <typename T>
void ShouldMatch(const void * buffer, size_t size, typename T::Digest &digest)
{
    T m;
    m.Append(buffer, size);
    m.Finalize();

    typename T::Digest obtained;
    m.GetResult(&obtained);

    XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&obtained, &digest, sizeof(typename T::Digest)), 0);

    m.Reset();
    const uint8_t * temp = (const uint8_t * ) buffer;
    for(size_t i = 0; i < size; i++)
    {
        m.Append(&temp[i], 1);
    }
    m.Finalize();

    m.GetResult(&obtained);

    XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&obtained, &digest, sizeof(typename T::Digest)), 0);
}

template <typename T>
void ShouldNotMatch(const void * buffer, size_t size, typename T::Digest &digest)
{
    T m;
    m.Append(buffer, size);
    m.Finalize();

    typename T::Digest obtained;
    m.GetResult(&obtained);

    XR_ASSERT_ALWAYS_NE( xr::Core::MemCompare8(&obtained, &digest, sizeof(typename T::Digest)), 0);
}

// --------------------------------------------------------------------------------------  FUNCTION
/*!  */
// --------------------------------------------------------------------------------------  FUNCTION
XR_UNITTEST_TEST_FUNC( vectorTests )
{
    // This is not exhaustive, there is an assumption this already works.
    ShouldMatch<xr::Core::CRC32>("", 0, sDigestNullStringCRC32);
    ShouldMatch<xr::Core::CRC32>("Hello", 5, sDigestHelloCRC32);
    ShouldMatch<xr::Core::CRC32>("testVector", 10, sDigestTestVectorCRC32);

    {
        xr::Core::CRC32::Digest d;
        d = xr::Core::CRC32::Process("");
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &sDigestNullStringCRC32, sizeof(xr::Core::CRC32::Digest)), 0);
        d = xr::Core::CRC32::Process("Hello");
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &sDigestHelloCRC32, sizeof(xr::Core::CRC32::Digest)), 0);

        // test that CRC can append values
        d = xr::Core::CRC32::ProcessAppend(d, "World");
        xr::Core::CRC32::Digest dKnown = 0x77770C79;
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &dKnown, sizeof(xr::Core::CRC32::Digest)), 0);
    }



    ShouldNotMatch<xr::Core::CRC32>("Hello", 4, sDigestHelloCRC32);
    ShouldNotMatch<xr::Core::CRC32>("HelLo", 5, sDigestHelloCRC32);
    ShouldNotMatch<xr::Core::CRC32>("notIt", 5, sDigestHelloCRC32);

    ShouldMatch<xr::Core::CRC32C>("", 0, sDigestNullStringCRC32C);
    ShouldMatch<xr::Core::CRC32C>("Hello", 5, sDigestHelloCRC32C);
    ShouldMatch<xr::Core::CRC32C>("testVector", 10, sDigestTestVectorCRC32C);

    {
        xr::Core::CRC32C::Digest d;
        d = xr::Core::CRC32C::Process("");
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &sDigestNullStringCRC32C, sizeof(xr::Core::CRC32C::Digest)), 0);
        d = xr::Core::CRC32C::Process("Hello");
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &sDigestHelloCRC32C, sizeof(xr::Core::CRC32C::Digest)), 0);

        // test that CRC can append values
        d = xr::Core::CRC32C::ProcessAppend(d, "World");
        xr::Core::CRC32C::Digest dKnown = 0xb0392b75;
        XR_ASSERT_ALWAYS_EQ( xr::Core::MemCompare8(&d, &dKnown, sizeof(xr::Core::CRC32C::Digest)), 0);
    }

    ShouldNotMatch<xr::Core::CRC32>("Hello", 4, sDigestHelloCRC32C);
    ShouldNotMatch<xr::Core::CRC32>("HelLo", 5, sDigestHelloCRC32C);
    ShouldNotMatch<xr::Core::CRC32>("notIt", 5, sDigestHelloCRC32C);

    ShouldMatch<xr::Core::MD5>("", 0, sDigestNullStringMD5);
    ShouldMatch<xr::Core::MD5>("Hello", 5, sDigestHelloMD5);
    ShouldMatch<xr::Core::MD5>("testVector", 10, sDigestTestVectorMD5);

    ShouldNotMatch<xr::Core::MD5>("Hello", 4, sDigestHelloMD5);
    ShouldNotMatch<xr::Core::MD5>("HelLo", 5, sDigestHelloMD5);
    ShouldNotMatch<xr::Core::MD5>("notIt", 5, sDigestHelloMD5);


    ShouldMatch<xr::Core::SHA1_160>("", 0, sDigestNullStringSHA1);
    ShouldMatch<xr::Core::SHA1_160>("Hello", 5, sDigestHelloSHA1);
    ShouldMatch<xr::Core::SHA1_160>("testVector", 10, sDigestTestVectorSHA1);

    ShouldNotMatch<xr::Core::SHA1_160>("Hello", 4, sDigestHelloSHA1);
    ShouldNotMatch<xr::Core::SHA1_160>("HelLo", 5, sDigestHelloSHA1);
    ShouldNotMatch<xr::Core::SHA1_160>("notIt", 5, sDigestHelloSHA1);

    ShouldMatch<xr::Core::SHA1_256>("", 0, sDigestNullString256);
    ShouldMatch<xr::Core::SHA1_256>("Hello", 5, sDigestHello256);
    ShouldMatch<xr::Core::SHA1_256>("testVector", 10, sDigestTestVector256);

    ShouldNotMatch<xr::Core::SHA1_256>("Hello", 4, sDigestHello256);
    ShouldNotMatch<xr::Core::SHA1_256>("HelLo", 5, sDigestHello256);
    ShouldNotMatch<xr::Core::SHA1_256>("notIt", 5, sDigestHello256);


    ShouldMatch<xr::Core::SHA1_224>("", 0, sDigestNullString224);
    ShouldMatch<xr::Core::SHA1_224>("Hello", 5, sDigestHello224);
    ShouldMatch<xr::Core::SHA1_224>("testVector", 10, sDigestTestVector224);

    ShouldNotMatch<xr::Core::SHA1_224>("Hello", 4, sDigestHello224);
    ShouldNotMatch<xr::Core::SHA1_224>("HelLo", 5, sDigestHello224);
    ShouldNotMatch<xr::Core::SHA1_224>("notIt", 5, sDigestHello224);


    ShouldMatch<xr::Core::SHA1_512>("", 0, sDigestNullString512);
    ShouldMatch<xr::Core::SHA1_512>("Hello", 5, sDigestHello512);
    ShouldMatch<xr::Core::SHA1_512>("testVector", 10, sDigestTestVector512);

    ShouldNotMatch<xr::Core::SHA1_512>("Hello", 4, sDigestHello512);
    ShouldNotMatch<xr::Core::SHA1_512>("HelLo", 5, sDigestHello512);
    ShouldNotMatch<xr::Core::SHA1_512>("notIt", 5, sDigestHello512);

    ShouldMatch<xr::Core::SHA1_384>("", 0, sDigestNullString384);
    ShouldMatch<xr::Core::SHA1_384>("Hello", 5, sDigestHello384);
    ShouldMatch<xr::Core::SHA1_384>("testVector", 10, sDigestTestVector384);

    ShouldNotMatch<xr::Core::SHA1_384>("Hello", 4, sDigestHello384);
    ShouldNotMatch<xr::Core::SHA1_384>("HelLo", 5, sDigestHello384);
    ShouldNotMatch<xr::Core::SHA1_384>("notIt", 5, sDigestHello384);

}


XR_UNITTEST_GROUP_END()

#endif // #if defined(XR_TEST_FEATURES_ENABLED)
